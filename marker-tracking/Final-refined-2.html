
<!doctype HTML>
<html>
    <head>
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
        #setup-overlay { position: fixed; inset: 0; background: #0b0b0c; color: #fff; display: flex; align-items: flex-start; justify-content: space-between; flex-direction: column; z-index: 2147483000; font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; padding: 20px; }
        #setup-overlay.hidden { display: none; }
        #setup-top-content { display: flex; flex-direction: column; gap: 20px; width: 100%; align-items: flex-start; padding-top: 20px; padding-left: 20px; padding-right: 20px; box-sizing: border-box; }
        #setup-heading { font-size: 40px; font-weight: 700; color: #fff; margin: 0; text-align: left; width: 100%; max-width: 100%; word-wrap: break-word; overflow-wrap: break-word; }
        #setup-description { font-size: 18px; color: rgba(255, 255, 255, 0.8); line-height: 1.7; margin: 0; text-align: left; max-width: 100%; width: 100%; word-wrap: break-word; overflow-wrap: break-word; box-sizing: border-box; }
        #setup-card { background: rgba(20, 20, 25, 0.95); backdrop-filter: blur(20px); border-radius: 16px; padding: 32px 28px; box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.1); min-width: 320px; max-width: 500px; width: calc(100% - 40px); display: flex; flex-direction: column; gap: 20px; margin-bottom: 20px; align-self: center; }
        #setup-status-container { display: flex; flex-direction: column; gap: 12px; }
        #setup-status-row { display: flex; align-items: center; justify-content: center; gap: 8px; }
        #setup-status { font-size: 13px; opacity: .9; text-align: center; color: rgba(255, 255, 255, 0.7); }
        #progress-container { width: 100%; margin-top: 4px; }
        #progress-bar { width: 100%; height: 6px; background: rgba(255, 255, 255, 0.15); border-radius: 3px; overflow: hidden; }
        #progress-fill { height: 100%; background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%); width: 0%; transition: width 0.3s ease; box-shadow: 0 0 8px rgba(34, 197, 94, 0.5); }
        #progress-text { font-size: 13px; opacity: .9; text-align: center; color: rgba(255, 255, 255, 0.7); }
        #setup-btn { appearance: none; border: none; background: #4a9eff; color: #fff; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: 600; margin-top: 8px; transition: all 0.3s ease; width: 100%; box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3); }
        #setup-btn:hover:not(:disabled) { background: #5baaff; transform: scale(1.02); box-shadow: 0 6px 16px rgba(74, 158, 255, 0.4); }
        #setup-btn:active:not(:disabled) { transform: scale(0.98); }
        #setup-btn:disabled { opacity: .6; cursor: default; background: #3a3b40; }
        @media (max-width: 768px) {
            #setup-overlay { padding: 15px; }
            #setup-top-content { padding-top: 10px; gap: 16px; padding-left: 15px; padding-right: 15px; }
            #setup-card { padding: 24px 20px; min-width: 280px; margin-bottom: 15px; }
            #setup-heading { font-size: 28px; }
            #setup-description { font-size: 16px; }
        }
        
        /* Navbar styles */
        #navbar { position: fixed; top: 0; left: 0; right: 0; height: 50px; background: #000; display: flex; align-items: center; justify-content: flex-start; padding: 0 20px; z-index: 2147482999; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        #navbar a { color: #fff; text-decoration: none; font-size: 16px; font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; transition: opacity 0.2s; }
        #navbar a:hover { opacity: 0.7; }
        
        /* Marker count bar */
        #marker-count-bar { position: fixed; top: 50px; left: 0; right: 0; height: 35px; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 2147482998; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
        #marker-count-left { display: flex; align-items: center; gap: 12px; }
        #marker-count-label { color: #999; font-size: 14px; font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; font-weight: 500; }
        #marker-boxes-container { display: flex; align-items: center; gap: 8px; }
        .marker-box { width: 24px; height: 24px; border: 2px solid #666; background: transparent; border-radius: 4px; transition: all 0.3s ease; }
        .marker-box.scanned { background: #22c55e; border-color: #22c55e; }
        #marker-count-display { color: #999; font-size: 14px; font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; font-weight: 500; }
        #marker-count-display .count-number { color: #fff; font-weight: 600; }
        
        /* Scanning guide overlay */
        #scanning-guide { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2147482997; pointer-events: none; display: none; }
        #scanning-guide.active { display: block; }
        #scanning-square { width: 250px; height: 250px; position: relative; }
        #scanning-square-corner-tl,
        #scanning-square-corner-tr,
        #scanning-square-corner-bl,
        #scanning-square-corner-br { position: absolute; width: 30px; height: 30px; border: 2px solid rgba(255, 255, 255, 0.4); }
        #scanning-square-corner-tl { top: 0; left: 0; border-right: none; border-bottom: none; }
        #scanning-square-corner-tr { top: 0; right: 0; border-left: none; border-bottom: none; }
        #scanning-square-corner-bl { bottom: 0; left: 0; border-right: none; border-top: none; }
        #scanning-square-corner-br { bottom: 0; right: 0; border-left: none; border-top: none; }
        #scanning-text { margin-top: 20px; text-align: center; color: rgba(255, 255, 255, 0.5); font-size: 16px; font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; text-shadow: 0 2px 4px rgba(0,0,0,0.5); font-weight: 500; }
        @media (max-width: 768px) {
            #scanning-square { width: 200px; height: 200px; }
            #scanning-square-corner-tl,
            #scanning-square-corner-tr,
            #scanning-square-corner-bl,
            #scanning-square-corner-br { width: 25px; height: 25px; }
            #scanning-text { font-size: 14px; margin-top: 15px; }
        }
        
        /* Music player UI - Floating Card Overlay */
        #music-player { 
            position: fixed; 
            bottom: 50px; 
            left: 50%; 
            transform: translateX(-50%); 
            background: rgba(20, 20, 25, 0.95); 
            backdrop-filter: blur(20px); 
            border-radius: 16px; 
            padding: 20px 20px; 
            z-index: 2147482997; 
            display: none; 
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.1); 
            min-width: 320px; 
            max-width: 500px; 
            width: calc(100% - 80px);
            margin: 0 auto;
        }
        #music-player.active { 
            display: block; 
            animation: slideUpFadeIn 0.3s ease-out;
        }
        
        @keyframes slideUpFadeIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        @keyframes slideText {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        #music-player-content { 
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
        }
        
        #music-player-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 4px;
        }
        
        #music-player-now-playing { 
            color: rgba(255, 255, 255, 0.7); 
            font-size: 11px; 
            font-weight: 600; 
            font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; 
            text-transform: uppercase; 
            letter-spacing: 1.5px;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: fadeIn 0.5s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        #music-player-now-playing-dot {
            width: 6px;
            height: 6px;
            background: #4a9eff;
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(74, 158, 255, 0.6);
        }
        
        #music-player-info { 
            flex: 1; 
            min-width: 0; 
        }
        
        #music-player-song-name { 
            color: #fff; 
            font-size: 18px; 
            font-weight: 600; 
            font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial; 
            margin-bottom: 12px; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis;
            line-height: 1.3;
            transition: opacity 0.3s ease;
        }
        
        #music-player-song-name.updating {
            animation: songNameUpdate 0.4s ease-out;
        }
        
        @keyframes songNameUpdate {
            0% { opacity: 0.5; transform: translateY(5px); }
            50% { opacity: 0.7; }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        #music-player-progress-container { 
            width: 100%; 
            height: 4px; 
            background: rgba(255, 255, 255, 0.15); 
            border-radius: 2px; 
            cursor: pointer; 
            position: relative; 
            overflow: hidden;
        }
        
        #music-player-progress-bar { 
            height: 100%; 
            background: linear-gradient(90deg, #4a9eff 0%, #6bb6ff 100%); 
            border-radius: 2px; 
            width: 0%; 
            transition: width 0.1s linear; 
            box-shadow: 0 0 8px rgba(74, 158, 255, 0.5);
        }
        
        #music-player-controls { 
            display: flex; 
            align-items: center; 
            justify-content: center;
            margin-top: 4px;
        }
        
        #music-player-play-pause { 
            background: rgba(255, 255, 255, 0.1); 
            border: 2px solid rgba(255, 255, 255, 0.3); 
            color: #fff; 
            width: 48px; 
            height: 48px; 
            border-radius: 50%; 
            cursor: pointer; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 20px; 
            transition: all 0.3s ease; 
            flex-shrink: 0;
            backdrop-filter: blur(10px);
        }
        
        #music-player-play-pause:hover { 
            background: rgba(255, 255, 255, 0.2); 
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        #music-player-play-pause:active { 
            transform: scale(0.95); 
        }
        
        @media (max-width: 768px) {
            #music-player { 
                bottom: 40px; 
                padding: 20px 20px; 
                min-width: 280px;
                width: calc(100% - 60px);
            }
            #music-player-song-name { 
                font-size: 16px; 
            }
            #music-player-play-pause { 
                width: 44px; 
                height: 44px; 
                font-size: 18px; 
            }
            #music-player-now-playing {
                font-size: 10px;
            }
        }
        </style>
    </head>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.loaders.min.js"></script>
    <script src="./scripts/gestures.js"></script>
    
    <body style='margin : 0px; overflow: hidden;'>
        <!-- Navbar -->
        <nav id="navbar">
            <a href="#" id="about-link">About</a>
        </nav>
        
        <!-- Marker count bar -->
        <div id="marker-count-bar">
            <div id="marker-count-left">
                <span id="marker-count-label">Markers Found</span>
                <div id="marker-boxes-container">
                    <div class="marker-box" id="marker-box-1"></div>
                    <div class="marker-box" id="marker-box-2"></div>
                </div>
            </div>
            <span id="marker-count-display"><span class="count-number" id="marker-count-number">0</span>/10</span>
        </div>
        
        <!-- Scanning guide overlay -->
        <div id="scanning-guide">
            <div id="scanning-square">
                <div id="scanning-square-corner-tl"></div>
                <div id="scanning-square-corner-tr"></div>
                <div id="scanning-square-corner-bl"></div>
                <div id="scanning-square-corner-br"></div>
            </div>
            <div id="scanning-text">Scan marker, keep the marker in this square</div>
        </div>
        
        <!-- Music player UI -->
        <div id="music-player">
            <div id="music-player-content">
                <div id="music-player-header">
                    <div id="music-player-now-playing">
                        <span id="music-player-now-playing-dot"></span>
                        <span>scan a puzzle piece</span>
                    </div>
                </div>
                <div id="music-player-info">
                    <div id="music-player-song-name">Welcome to the Music Man Project! Scan the 1st puzzle piece to get started.</div>
                    <div id="music-player-progress-container">
                        <div id="music-player-progress-bar"></div>
                    </div>
                </div>
                <div id="music-player-controls">
                    <button id="music-player-play-pause">‚è∏</button>
                </div>
            </div>
        </div>
        
        <!-- we add detectionMode and matrixCodeType to tell AR.js to recognize barcode markers -->
        <div id="setup-overlay">
            <div id="setup-top-content">
                <h1 id="setup-heading">Welcome to the Music Man Project</h1>
                <p id="setup-description">Experience an immersive Augmented Reality journey where music comes to life through marker tracking. Scan barcode markers to trigger 3D models and synchronized audio tracks, creating an interactive musical experience that blends the digital and physical worlds.</p>
            </div>
            <div id="setup-card">
                <div id="setup-status-container">
                    <div id="setup-status-row">
                        <div id="setup-status">Loading assets...</div>
                        <div id="progress-text">0%</div>
                    </div>
                    <div id="progress-container">
                        <div id="progress-bar">
                            <div id="progress-fill"></div>
                        </div>
                    </div>
                </div>
                <button id="setup-btn" disabled>Start</button>
            </div>
        </div>
        <a-scene 
        vr-mode-ui="enabled: false;"
        renderer="logarithmicDepthBuffer: true;"
        embedded 
        loading-screen="enabled: false"
        arjs='sourceType: webcam; debugUIEnabled: true; detectionMode: mono_and_matrix; matrixCodeType: 3x3;'
        gesture-detector>

        <audio id="audio1" src="assets/audio/audio-1.mp3" preload="true"></audio>
        <audio id="audio2" src="assets/audio/audio-2.mp3" preload="true"></audio>



        <a-assets>
            <a-asset-item id="animated-asset" src="https://raw.githubusercontent.com/nicolocarpignoli/nicolocarpignoli.github.io/master/ar-playground/models/CesiumMan.gltf"></a-asset-item>
        </a-assets>

        <a-marker id="marker-1" type='barcode' value='1' sound="src: #audio1; positional: false; loop: false; volume: 1;">
            <a-box position='0 0.5 0' color="yellow" gesture-handler></a-box>
        </a-marker>

        <a-marker id="marker-2" type='barcode' value='2' sound="src: #audio2; positional: false; loop: false; volume: 1;">
            <a-entity
                gltf-model="#animated-asset"
                scale="2"
                gesture-handler>
            </a-entity>
        </a-marker>

        <!-- use this <a-entity camera> to support multiple-markers, otherwise use <a-marker-camera> instead of </a-marker> -->
        <a-entity camera></a-entity>
        </a-scene>
        <script src="./debug.js"></script>
        <script>
        (function(){
            // Setup/loading overlay controller
            var overlay = document.getElementById('setup-overlay');
            var statusEl = document.getElementById('setup-status');
            var progressFill = document.getElementById('progress-fill');
            var progressText = document.getElementById('progress-text');
            var btn = document.getElementById('setup-btn');
            var scene = document.querySelector('a-scene');
            var assets = document.querySelector('a-assets');
            var audioEls = [document.getElementById('audio1'), document.getElementById('audio2')].filter(Boolean);

            // Loading state tracking - more granular
            var loadingState = {
                gltfModel: false,
                scene: false,
                audio1: false,
                audio2: false,
                scripts: false
            };

            var totalItems = Object.keys(loadingState).length;
            var loadedItems = 0;
            var isAllReady = false;

            function updateProgress(item, loaded) {
                if (loadingState[item] !== loaded) {
                    loadingState[item] = loaded;
                    if (loaded) {
                        loadedItems++;
                    } else {
                        loadedItems--;
                    }
                }
                var percent = Math.round((loadedItems / totalItems) * 100);
                progressFill.style.width = percent + '%';
                progressText.textContent = percent + '%';
            }

            function updateStatus() {
                var status = [];
                if (!loadingState.gltfModel) status.push('Loading 3D model...');
                if (!loadingState.audio1 || !loadingState.audio2) status.push('Loading audio files...');
                if (!loadingState.scene) status.push('Initializing AR camera...');
                if (!loadingState.scripts) status.push('Loading scripts...');
                
                if (status.length > 0) {
                    statusEl.textContent = status[0];
                } else {
                    statusEl.textContent = 'Ready!';
                }
            }

            function checkAllReady() {
                var allReady = Object.keys(loadingState).every(function(key) {
                    return loadingState[key] === true;
                });

                if (allReady && !isAllReady) {
                    isAllReady = true;
                    statusEl.textContent = 'Ready!';
                    btn.disabled = false;
                    // Small delay to ensure everything is truly ready
                    setTimeout(function() {
                        if (isAllReady) {
                            btn.disabled = false;
                        }
                    }, 100);
                } else {
                    btn.disabled = true;
                }
            }

            // Detect mobile devices
            function isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                       (window.innerWidth <= 768);
            }

            // Track scripts loading
            var scriptCheckAttempts = 0;
            var maxScriptCheckAttempts = 50; // 5 seconds max
            
            function checkScriptsLoaded() {
                scriptCheckAttempts++;
                
                // Check if A-Frame is loaded
                var aframeLoaded = typeof AFRAME !== 'undefined';
                
                // Check if gesture components are registered
                var gesturesLoaded = aframeLoaded && 
                    AFRAME.components['gesture-handler'] && 
                    AFRAME.components['gesture-detector'];
                
                // AR.js is loaded if the scene has the arjs attribute/component
                var arjsLoaded = scene && (scene.hasAttribute('arjs') || scene.components.arjs);
                
                if (aframeLoaded && gesturesLoaded && (arjsLoaded || scriptCheckAttempts > 10)) {
                    // AR.js might not expose a global, but if A-Frame and gestures are loaded, we're good
                    updateProgress('scripts', true);
                    updateStatus();
                    checkAllReady();
                } else if (scriptCheckAttempts < maxScriptCheckAttempts) {
                    // Retry after a short delay
                    setTimeout(checkScriptsLoaded, 100);
                } else {
                    // Timeout - assume scripts are loaded to not block the app
                    console.warn('Script loading check timeout, proceeding anyway');
                    updateProgress('scripts', true);
                    updateStatus();
                    checkAllReady();
                }
            }

            // Start checking scripts after DOM is ready
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                setTimeout(checkScriptsLoaded, 50);
            } else {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(checkScriptsLoaded, 50);
                });
            }

            // Track GLTF model loading specifically
            function trackGLTFModel() {
                var gltfEntity = document.querySelector('a-entity[gltf-model]');
                var assetItem = document.querySelector('#animated-asset');
                
                if (!assetItem) {
                    // No GLTF model to load
                    updateProgress('gltfModel', true);
                    checkAllReady();
                    return;
                }

                // Track asset item loading
                var assetLoaded = false;
                var mobileDevice = isMobile();
                // On mobile, use shorter timeout for model loading
                var modelTimeout = mobileDevice ? 8000 : 10000;
                
                function markGLTFLoaded() {
                    if (!assetLoaded) {
                        assetLoaded = true;
                        // On mobile, be more lenient - don't require children to be loaded
                        if (mobileDevice) {
                            updateProgress('gltfModel', true);
                            updateStatus();
                            checkAllReady();
                        } else {
                            // Double check the model is actually loaded (desktop)
                            setTimeout(function() {
                                if (gltfEntity && gltfEntity.object3D && gltfEntity.object3D.children.length > 0) {
                                    updateProgress('gltfModel', true);
                                    updateStatus();
                                    checkAllReady();
                                } else {
                                    // Model might still be loading, wait a bit more
                                    setTimeout(markGLTFLoaded, 200);
                                }
                            }, 100);
                        }
                    }
                }

                // Listen for asset loaded event
                assetItem.addEventListener('loaded', markGLTFLoaded);
                
                // Also listen on the entity itself
                if (gltfEntity) {
                    gltfEntity.addEventListener('model-loaded', markGLTFLoaded);
                    gltfEntity.addEventListener('loaded', markGLTFLoaded);
                }

                // Listen for assets loaded
                if (assets) {
                    assets.addEventListener('loaded', function() {
                        setTimeout(markGLTFLoaded, 100);
                    });
                }

                // On mobile, also check if asset item has src attribute (indicates it's at least trying to load)
                if (mobileDevice) {
                    setTimeout(function() {
                        if (!assetLoaded && assetItem && assetItem.hasAttribute('src')) {
                            console.log('GLTF model asset detected on mobile, proceeding');
                            markGLTFLoaded();
                        }
                    }, 2000);
                }

                // Fallback timeout - mark as loaded after reasonable time
                setTimeout(function() {
                    if (!assetLoaded) {
                        console.warn('GLTF model loading timeout, proceeding anyway');
                        markGLTFLoaded();
                    }
                }, modelTimeout);
            }

            // Track assets loading
            if (assets) {
                assets.addEventListener('loaded', function(){
                    trackGLTFModel();
                });
                assets.addEventListener('progress', function(e) {
                    if (e.detail && e.detail.total > 0) {
                        var assetPercent = Math.round((e.detail.loaded / e.detail.total) * 100);
                        if (assetPercent === 100) {
                            trackGLTFModel();
                        }
                    }
                });
                // Start tracking GLTF after a short delay to ensure assets element is ready
                setTimeout(trackGLTFModel, 100);
            } else {
                updateProgress('gltfModel', true);
                checkAllReady();
            }

            // Track scene loading
            if (scene) {
                var sceneReadyFired = false;
                var mobileDevice = isMobile();
                var markSceneReady = function(){ 
                    if (!sceneReadyFired) {
                        sceneReadyFired = true;
                        updateProgress('scene', true);
                        updateStatus();
                        checkAllReady();
                    }
                };
                scene.addEventListener('loaded', markSceneReady);
                scene.addEventListener('arReady', markSceneReady);
                scene.addEventListener('renderstart', markSceneReady);
                
                // Fallback - check if scene is already loaded
                if (scene.hasLoaded) {
                    markSceneReady();
                }
                
                // On mobile, be more lenient - mark scene as ready after a shorter timeout
                // AR.js initialization can be slower on mobile devices
                setTimeout(function() {
                    if (!sceneReadyFired) {
                        // Check if scene has at least started initializing
                        if (scene.hasLoaded || (scene.components && scene.components.renderer)) {
                            console.log('Scene initialization detected on mobile, proceeding');
                            markSceneReady();
                        } else if (mobileDevice) {
                            // On mobile, proceed anyway after timeout to avoid blocking
                            console.warn('Scene loading timeout on mobile, proceeding anyway');
                            markSceneReady();
                        }
                    }
                }, mobileDevice ? 5000 : 10000);
            } else {
                updateProgress('scene', true);
                checkAllReady();
            }

            // Robust audio preloading
            function preloadAudio() {
                if (audioEls.length === 0) {
                    updateProgress('audio1', true);
                    updateProgress('audio2', true);
                    checkAllReady();
                    return;
                }

                var audioStates = {};
                audioEls.forEach(function(audio, index) {
                    if (!audio) {
                        audioStates['audio' + (index + 1)] = true;
                        return;
                    }
                    audioStates['audio' + (index + 1)] = false;
                });

                function checkAudioReady(audioIndex) {
                    var key = 'audio' + audioIndex;
                    if (!audioStates[key]) {
                        audioStates[key] = true;
                        updateProgress(key, true);
                        updateStatus();
                        checkAllReady();
                    }
                }

                var mobileDevice = isMobile();
                // On mobile, use shorter timeout since audio may require user interaction
                var audioTimeout = mobileDevice ? 3000 : 8000;

                audioEls.forEach(function(audio, index) {
                    if (!audio) {
                        checkAudioReady(index + 1);
                        return;
                    }

                    var audioIndex = index + 1;
                    var loaded = false;

                    // Set preload attribute
                    audio.preload = 'auto';
                    
                    // On mobile, try to load but don't block if it fails
                    try {
                        audio.load(); // Force load
                    } catch(e) {
                        console.warn('Audio load() failed, will use timeout fallback');
                    }

                    function markAudioLoaded() {
                        if (!loaded) {
                            loaded = true;
                            checkAudioReady(audioIndex);
                        }
                    }

                    function handleError() {
                        console.warn('Audio ' + audioIndex + ' failed to load:', audio.src);
                        // Still mark as loaded to not block the app
                        markAudioLoaded();
                    }

                    // Multiple event listeners for robustness
                    var events = ['canplaythrough', 'loadeddata', 'loadedmetadata', 'canplay'];
                    events.forEach(function(eventName) {
                        audio.addEventListener(eventName, function() {
                            if (audio.readyState >= 2) { // HAVE_CURRENT_DATA or better
                                markAudioLoaded();
                            }
                        }, { once: true });
                    });

                    audio.addEventListener('error', handleError, { once: true });

                    // Check if already loaded
                    if (audio.readyState >= 2) {
                        markAudioLoaded();
                    }

                    // On mobile, be more lenient - mark as loaded even if not fully ready
                    // Mobile browsers often block audio preloading until user interaction
                    if (mobileDevice) {
                        // Check after a short delay if metadata is loaded
                        setTimeout(function() {
                            if (!loaded && audio.readyState >= 1) { // HAVE_METADATA or better
                                console.log('Audio ' + audioIndex + ' metadata loaded on mobile, proceeding');
                                markAudioLoaded();
                            }
                        }, 1000);
                    }

                    // Fallback timeout - shorter on mobile
                    setTimeout(function() {
                        if (!loaded) {
                            console.warn('Audio ' + audioIndex + ' loading timeout, proceeding anyway (mobile-friendly)');
                            markAudioLoaded();
                        }
                    }, audioTimeout);
                });
            }

            // Start audio preloading
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                setTimeout(preloadAudio, 100);
            } else {
                document.addEventListener('DOMContentLoaded', function() {
                    setTimeout(preloadAudio, 100);
                });
            }

            // Initial status update
            updateStatus();

            // Prevent button click if not ready
            btn.addEventListener('click', function(e){
                if (btn.disabled || !isAllReady) {
                    e.preventDefault();
                    return false;
                }

                // Final verification before starting
                var allAssetsReady = loadingState.gltfModel && loadingState.scene && 
                                    loadingState.audio1 && loadingState.audio2 && 
                                    loadingState.scripts;

                if (!allAssetsReady) {
                    statusEl.textContent = 'Still loading, please wait...';
                    return false;
                }

                // Attempt to unlock audio by playing and pausing muted
                try {
                    audioEls.forEach(function(a){ 
                        if (a) { 
                            a.muted = true; 
                            a.play().then(function(){ 
                                a.pause(); 
                                a.currentTime = 0; 
                                a.muted = false; 
                            }).catch(function(){}); 
                        } 
                    }); 
                } catch(_){ }
                
                overlay.classList.add('hidden');
                
                // Show scanning guide when AR is active
                var scanningGuide = document.getElementById('scanning-guide');
                if (scanningGuide) {
                    scanningGuide.classList.add('active');
                }
                
                // Show music player with welcome message
                var musicPlayer = document.getElementById('music-player');
                if (musicPlayer) {
                    musicPlayer.classList.add('active');
                }
            });
        })();

        (function(){
            var marker1 = document.getElementById('marker-1');
            var marker2 = document.getElementById('marker-2');
            
            // Track active marker and persistence timers
            var activeMarker = null;
            var persistenceTimer = null;
            var visibilityCheckInterval = null;
            var PERSISTENCE_DURATION = 20000; // 30 seconds in milliseconds
            
            // Marker tracking state
            var currentMarker = null; // Currently active marker
            var lastMarker = null; // Previously active marker
            var scannedMarkers = new Set(); // Set of marker IDs that have been scanned
            var allMarkers = ['marker-1', 'marker-2']; // All available markers
            
            // Helper function to get marker ID
            function getMarkerId(marker) {
                if (!marker) return null;
                return marker.id || (marker.getAttribute ? marker.getAttribute('id') : null);
            }
            
            // Helper function to get marker element by ID
            function getMarkerById(markerId) {
                if (!markerId) return null;
                return document.getElementById(markerId);
            }
            
            // Function to stop all audio elements
            function stopAllAudio() {
                var audio1 = document.getElementById('audio1');
                var audio2 = document.getElementById('audio2');
                
                [audio1, audio2].forEach(function(audio) {
                    if (audio) {
                        try {
                            audio.pause();
                            // Don't reset currentTime - let user resume from where they paused
                        } catch(e) {
                            console.warn('Error stopping audio:', e);
                        }
                    }
                });
                
                // Also stop via sound components
                var marker1 = document.getElementById('marker-1');
                var marker2 = document.getElementById('marker-2');
                
                [marker1, marker2].forEach(function(marker) {
                    if (marker && marker.components && marker.components.sound) {
                        try {
                            marker.components.sound.stopSound();
                        } catch(e) {
                            // Ignore errors
                        }
                    }
                });
            }
            
            // Function to play audio based on currentMarker value
            function playAudioForCurrentMarker() {
                if (!currentMarker) {
                    console.log('No current marker, skipping audio playback');
                    return;
                }
                
                // Stop all audio first to ensure only current audio plays
                stopAllAudio();
                
                var marker = getMarkerById(currentMarker);
                if (!marker) {
                    console.warn('Marker element not found for:', currentMarker);
                    return;
                }
                
                // Get audio element and song name for the current marker
                var audioEl = getAudioElement(marker);
                var songName = getSongNameForMarker(marker);
                
                if (!audioEl) {
                    console.warn('No audio element found for current marker:', currentMarker);
                    // Try again after a short delay
                    setTimeout(function() {
                        var delayedAudioEl = getAudioElement(marker);
                        if (delayedAudioEl && typeof window.updateMusicPlayerForMarker === 'function') {
                            console.log('Got audio element on retry:', delayedAudioEl);
                            window.updateMusicPlayerForMarker(delayedAudioEl, songName);
                            playAudioElement(delayedAudioEl, songName);
                        }
                    }, 200);
                    return;
                }
                
                // Update music player
                if (typeof window.updateMusicPlayerForMarker === 'function') {
                    console.log('Updating music player for current marker:', { audioEl: audioEl, songName: songName });
                    window.updateMusicPlayerForMarker(audioEl, songName);
                }
                
                // Play the current marker's audio
                playAudioElement(audioEl, songName);
            }
            
            // Helper function to play audio element
            function playAudioElement(audioEl, songName) {
                if (!audioEl) return;
                
                var soundOn = typeof window.soundEnabled !== 'undefined' ? window.soundEnabled : true;
                if (!soundOn) {
                    console.log('Sound is disabled, not playing audio');
                    return;
                }
                
                try {
                    // Reset audio to start when switching markers
                    // This ensures the new marker's audio starts from the beginning
                    audioEl.currentTime = 0;
                    
                    // Play audio
                    var playPromise = audioEl.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(function() {
                            console.log('Audio started playing successfully for current marker');
                            // Music player is already updated, just ensure it's tracking
                            if (typeof window.ensureMusicPlayerTracking === 'function') {
                                window.ensureMusicPlayerTracking(audioEl);
                            }
                            // Also update again to be sure
                            if (typeof window.updateMusicPlayerForMarker === 'function') {
                                window.updateMusicPlayerForMarker(audioEl, songName);
                            }
                        }).catch(function(error) {
                            console.warn('Audio play() failed:', error);
                            // Auto-play was prevented or failed
                            // Try using sound component as fallback
                            var marker = getMarkerById(currentMarker);
                            if (marker && marker.components && marker.components.sound) {
                                try {
                                    marker.components.sound.playSound();
                                    // Update music player after sound component plays
                                    if (audioEl && typeof window.updateMusicPlayerForMarker === 'function') {
                                        window.updateMusicPlayerForMarker(audioEl, songName);
                                    }
                                } catch(e) {
                                    console.warn('Sound component playback failed:', e);
                                }
                            }
                        });
                    }
                } catch(e) {
                    console.warn('Audio play error:', e);
                    // Fallback to sound component if direct play fails
                    var marker = getMarkerById(currentMarker);
                    if (marker && marker.components && marker.components.sound) {
                        try {
                            marker.components.sound.playSound();
                            // Update music player after sound component plays
                            if (audioEl && typeof window.updateMusicPlayerForMarker === 'function') {
                                window.updateMusicPlayerForMarker(audioEl, songName);
                            }
                        } catch(e2) {
                            console.warn('Sound component playback failed:', e2);
                        }
                    }
                }
            }
            
            // Helper function to get remaining markers (not yet scanned)
            function getRemainingMarkers() {
                return allMarkers.filter(function(markerId) {
                    return !scannedMarkers.has(markerId);
                });
            }
            
            // Function to update marker count display
            function updateMarkerCountDisplay() {
                // Update each marker box based on scanned status
                allMarkers.forEach(function(markerId) {
                    var boxEl = document.getElementById('marker-box-' + markerId.split('-')[1]);
                    if (boxEl) {
                        if (scannedMarkers.has(markerId)) {
                            boxEl.classList.add('scanned');
                        } else {
                            boxEl.classList.remove('scanned');
                        }
                    }
                });
                
                // Update count display
                var countEl = document.getElementById('marker-count-number');
                if (countEl) {
                    countEl.textContent = scannedMarkers.size;
                }
            }
            
            // Expose marker tracking state globally
            window.markerTracking = {
                getCurrentMarker: function() { return currentMarker; },
                getLastMarker: function() { return lastMarker; },
                getScannedMarkers: function() { return Array.from(scannedMarkers); },
                getRemainingMarkers: function() { return getRemainingMarkers(); },
                getAllMarkers: function() { return allMarkers.slice(); }
            };

            function getAudioElement(marker) {
                if (!marker) return null;
                
                // Method 1: Get by marker value (most reliable)
                var markerValue = marker.getAttribute('value');
                if (markerValue === '1') {
                    var audio1 = document.getElementById('audio1');
                    if (audio1) return audio1;
                } else if (markerValue === '2') {
                    var audio2 = document.getElementById('audio2');
                    if (audio2) return audio2;
                }
                
                // Method 2: Try to get from sound component
                if (marker.components && marker.components.sound) {
                    var soundSrc = marker.components.sound.data.src;
                    if (soundSrc && typeof soundSrc === 'string' && soundSrc.startsWith('#')) {
                        var audioEl = document.querySelector(soundSrc);
                        if (audioEl) return audioEl;
                    }
                }
                
                // Method 3: Try to get from sound attribute (if it's a string)
                var soundAttr = marker.getAttribute('sound');
                if (soundAttr && typeof soundAttr === 'string') {
                    // Parse the sound attribute (format: "src: #audio1; ...")
                    var srcMatch = soundAttr.match(/src:\s*([^;]+)/);
                    if (srcMatch) {
                        var src = srcMatch[1].trim();
                        if (src.startsWith('#')) {
                            var audioEl = document.querySelector(src);
                            if (audioEl) return audioEl;
                        }
                    }
                } else if (soundAttr && typeof soundAttr === 'object' && soundAttr.src) {
                    // If soundAttr is an object (A-Frame component data), use src property
                    var src = soundAttr.src;
                    if (src && typeof src === 'string' && src.startsWith('#')) {
                        var audioEl = document.querySelector(src);
                        if (audioEl) return audioEl;
                    }
                }
                
                return null;
            }

            function resetMarker(marker) {
                if (!marker) return;
                
                // Don't stop audio - let it continue playing
                // Audio is controlled by the play/pause button
                
                // Hide the marker's children (model/box)
                var children = marker.children;
                for (var i = 0; i < children.length; i++) {
                    if (children[i].object3D) {
                        children[i].object3D.visible = false;
                    }
                }
            }

            function showMarker(marker) {
                if (!marker) return;
                
                // Show the marker's children (model/box)
                var children = marker.children;
                for (var i = 0; i < children.length; i++) {
                    if (children[i].object3D) {
                        children[i].object3D.visible = true;
                    }
                }
            }

            function getSongNameForMarker(marker) {
                if (!marker) return 'Unknown Track';
                var markerValue = marker.getAttribute('value');
                var audioId = markerValue === '1' ? 'audio1' : (markerValue === '2' ? 'audio2' : null);
                if (audioId === 'audio1') return 'Audio Track 1';
                if (audioId === 'audio2') return 'Audio Track 2';
                return 'Unknown Track';
            }

            function handleMarkerFound(marker) {
                // Clear any existing timers and intervals
                if (persistenceTimer) {
                    clearTimeout(persistenceTimer);
                    persistenceTimer = null;
                }
                if (visibilityCheckInterval) {
                    clearInterval(visibilityCheckInterval);
                    visibilityCheckInterval = null;
                }
                
                // If a different marker is active, reset it immediately
                if (activeMarker && activeMarker !== marker) {
                    resetMarker(activeMarker);
                }
                
                // Update marker tracking state
                var markerId = getMarkerId(marker);
                if (markerId) {
                    // Update last marker before setting current
                    if (currentMarker && currentMarker !== markerId) {
                        lastMarker = currentMarker;
                    }
                    
                    // Set current marker
                    currentMarker = markerId;
                    
                    // Add to scanned markers if not already scanned
                    var wasNewMarker = !scannedMarkers.has(markerId);
                    scannedMarkers.add(markerId);
                    
                    // Update marker count display if this is a new marker
                    if (wasNewMarker) {
                        updateMarkerCountDisplay();
                    }
                    
                    console.log('Marker tracking updated:', {
                        currentMarker: currentMarker,
                        lastMarker: lastMarker,
                        scannedMarkers: Array.from(scannedMarkers),
                        remainingMarkers: getRemainingMarkers()
                    });
                    
                    // Play audio based on currentMarker value
                    playAudioForCurrentMarker();
                }
                
                // Set new active marker
                activeMarker = marker;
                
                // Show the marker's content
                showMarker(marker);
                
                console.log('Marker detected:', {
                    currentMarker: markerId,
                    lastMarker: lastMarker,
                    markerValue: marker.getAttribute('value')
                });
            }

            function handleMarkerLost(marker) {
                // Only handle if this is the currently active marker
                if (activeMarker !== marker) return;
                
                // Clear any existing timer
                if (persistenceTimer) {
                    clearTimeout(persistenceTimer);
                }
                if (visibilityCheckInterval) {
                    clearInterval(visibilityCheckInterval);
                }
                
                // Keep models visible during persistence period
                // Audio continues playing - controlled by play/pause button
                visibilityCheckInterval = setInterval(function() {
                    if (activeMarker === marker) {
                        showMarker(marker);
                        // Audio is controlled by the music player play/pause button
                        // Don't auto-restart it here
                    } else {
                        clearInterval(visibilityCheckInterval);
                        visibilityCheckInterval = null;
                    }
                }, 100); // Check every 100ms
                
                // Start persistence timer - keep model visible for 30 seconds
                // Audio continues playing regardless - controlled by play/pause button
                persistenceTimer = setTimeout(function() {
                    if (visibilityCheckInterval) {
                        clearInterval(visibilityCheckInterval);
                        visibilityCheckInterval = null;
                    }
                    // After 30 seconds, hide the marker's visual content
                    // But don't stop audio - let it continue playing
                    if (activeMarker === marker) {
                        resetMarker(marker);
                        activeMarker = null;
                        
                        // Update tracking: clear current marker (but keep in scannedMarkers)
                        var markerId = getMarkerId(marker);
                        if (currentMarker === markerId) {
                            currentMarker = null;
                            console.log('Marker tracking updated (marker lost):', {
                                currentMarker: currentMarker,
                                lastMarker: lastMarker,
                                scannedMarkers: Array.from(scannedMarkers),
                                remainingMarkers: getRemainingMarkers()
                            });
                        }
                    }
                    persistenceTimer = null;
                }, PERSISTENCE_DURATION);
            }

            function bindSoundHandlers(marker){
                if(!marker) return;
                
                marker.addEventListener('markerFound', function(){
                    handleMarkerFound(marker);
                });
                
                marker.addEventListener('markerLost', function(){
                    handleMarkerLost(marker);
                });
            }

            // If components not yet initialized, wait for scene to load
            function onLoaded(){
                bindSoundHandlers(marker1);
                bindSoundHandlers(marker2);
                // Initialize marker boxes display
                updateMarkerCountDisplay();
            }
            if (document.readyState === 'complete') onLoaded();
            else window.addEventListener('load', onLoaded);
        })();

        // Sound functionality (sound is always enabled, no toggle button)
        (function(){
            var aboutLink = document.getElementById('about-link');
            // Make soundEnabled globally accessible for marker handlers
            window.soundEnabled = true;
            
            // About link handler (you can customize this)
            if (aboutLink) {
                aboutLink.addEventListener('click', function(e) {
                    e.preventDefault();
                    alert('AR Demo - Marker Tracking\n\nThis demo uses AR.js to track barcode markers and display 3D models with audio.');
                });
            }
        })();

        // Music player control
        (function(){
            // Expose functions immediately, even before DOM elements are ready
            // This ensures they're available when markers are detected
            var musicPlayer = null;
            var songNameEl = null;
            var progressBar = null;
            var progressContainer = null;
            var playPauseBtn = null;
            var nowPlayingText = null;
            
            var currentAudio = null;
            var progressUpdateInterval = null;
            var isPaused = false;
            var isInitialState = true; // Track if we're in the initial welcome state
            
            // Song names mapping
            var songNames = {
                'audio1': 'Audio Track 1',
                'audio2': 'Audio Track 2'
            };
            
            // Initialize DOM elements
            function initDOMElements() {
                if (!musicPlayer) musicPlayer = document.getElementById('music-player');
                if (!songNameEl) songNameEl = document.getElementById('music-player-song-name');
                if (!progressBar) progressBar = document.getElementById('music-player-progress-bar');
                if (!progressContainer) progressContainer = document.getElementById('music-player-progress-container');
                if (!playPauseBtn) playPauseBtn = document.getElementById('music-player-play-pause');
                if (!nowPlayingText) {
                    var nowPlayingEl = document.getElementById('music-player-now-playing');
                    if (nowPlayingEl) {
                        var span = nowPlayingEl.querySelector('span:last-child');
                        if (span) nowPlayingText = span;
                    }
                }
            }
            
            // Try to initialize immediately
            initDOMElements();
            
            // Also try after DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDOMElements);
            }
            
            // And after a short delay to be safe
            setTimeout(initDOMElements, 100);
            
            // Expose functions immediately (before they're fully defined)
            // This ensures they're available as soon as possible
            window.updateMusicPlayerForMarker = function(audioElement, songName) {
                initDOMElements();
                
                console.log('updateMusicPlayerForMarker called:', {
                    audioElement: audioElement,
                    songName: songName,
                    musicPlayer: musicPlayer
                });
                
                if (!audioElement) {
                    console.warn('updateMusicPlayerForMarker: No audio element provided');
                    return;
                }
                if (!musicPlayer) {
                    console.warn('updateMusicPlayerForMarker: Music player not ready, will retry');
                    setTimeout(function() {
                        initDOMElements();
                        if (musicPlayer && audioElement) {
                            console.log('Retry: Updating music player');
                            showMusicPlayer(audioElement, songName);
                        } else {
                            console.warn('Retry failed: musicPlayer or audioElement still not available');
                        }
                    }, 100);
                    return;
                }
                console.log('Calling showMusicPlayer');
                showMusicPlayer(audioElement, songName);
            };
            
            // Function to show music player
            function showMusicPlayer(audioElement, songName) {
                // Ensure DOM elements are initialized
                initDOMElements();
                
                console.log('showMusicPlayer called:', {
                    audioElement: audioElement,
                    songName: songName,
                    musicPlayer: musicPlayer,
                    songNameEl: songNameEl
                });
                
                if (!musicPlayer) {
                    console.warn('Music player element not found, retrying...');
                    // Retry after a short delay
                    setTimeout(function() {
                        initDOMElements();
                        if (musicPlayer && audioElement) {
                            showMusicPlayer(audioElement, songName);
                        }
                    }, 100);
                    return;
                }
                if (!audioElement) {
                    console.warn('Audio element not provided to showMusicPlayer');
                    return;
                }
                
                currentAudio = audioElement;
                
                // Mark that we're no longer in initial state (marker detected)
                isInitialState = false;
                
                // Update "Now Playing" text when a marker is detected
                if (nowPlayingText) {
                    nowPlayingText.textContent = 'Now Playing';
                }
                
                if (songNameEl) {
                    // Trigger animation when song name changes
                    var previousName = songNameEl.textContent;
                    if (previousName && previousName !== songName) {
                        songNameEl.classList.add('updating');
                        setTimeout(function() {
                            if (songNameEl) {
                                songNameEl.classList.remove('updating');
                            }
                        }, 400);
                    }
                    songNameEl.textContent = songName || 'Unknown Track';
                    console.log('Updated song name to:', songName);
                }
                musicPlayer.classList.add('active');
                console.log('Music player set to active');
                updatePlayPauseButton();
                startProgressUpdate();
                
                // Force immediate progress update
                updateProgress();
            }
            
            // Function to hide music player
            function hideMusicPlayer() {
                if (!musicPlayer) return;
                musicPlayer.classList.remove('active');
                currentAudio = null;
                stopProgressUpdate();
            }
            
            // Function to update progress bar
            function updateProgress() {
                if (!currentAudio || !progressBar) return;
                
                if (currentAudio.duration && currentAudio.duration > 0) {
                    var percent = (currentAudio.currentTime / currentAudio.duration) * 100;
                    progressBar.style.width = percent + '%';
                }
                
                // Keep player visible even when audio ends - don't hide it
            }
            
            // Start progress update interval
            function startProgressUpdate() {
                stopProgressUpdate();
                // Keep updating progress even when paused/ended to show current position
                progressUpdateInterval = setInterval(updateProgress, 100);
            }
            
            // Stop progress update interval
            function stopProgressUpdate() {
                if (progressUpdateInterval) {
                    clearInterval(progressUpdateInterval);
                    progressUpdateInterval = null;
                }
            }
            
            // Update play/pause button
            function updatePlayPauseButton() {
                if (!playPauseBtn || !currentAudio) return;
                
                if (currentAudio.paused || isPaused || currentAudio.ended) {
                    playPauseBtn.textContent = '‚ñ∂';
                } else {
                    playPauseBtn.textContent = '‚è∏';
                }
            }
            
            // Handle play/pause button click
            if (playPauseBtn) {
                playPauseBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    if (!currentAudio) return;
                    
                    if (currentAudio.paused || isPaused || currentAudio.ended) {
                        // If audio ended, restart from beginning
                        if (currentAudio.ended) {
                            currentAudio.currentTime = 0;
                        }
                        currentAudio.play().catch(function(err) {
                            console.warn('Could not play audio:', err);
                        });
                        isPaused = false;
                        if (!progressUpdateInterval) {
                            startProgressUpdate();
                        }
                    } else {
                        currentAudio.pause();
                        isPaused = true;
                    }
                    updatePlayPauseButton();
                });
            }
            
            // Handle progress bar click to seek
            if (progressContainer) {
                progressContainer.addEventListener('click', function(e) {
                    if (!currentAudio || !currentAudio.duration) return;
                    
                    var rect = progressContainer.getBoundingClientRect();
                    var clickX = e.clientX - rect.left;
                    var percent = clickX / rect.width;
                    var newTime = percent * currentAudio.duration;
                    
                    currentAudio.currentTime = Math.max(0, Math.min(newTime, currentAudio.duration));
                    updateProgress();
                });
            }
            
            // Secondary function: Ensure player is tracking the audio (called after audio starts)
            window.ensureMusicPlayerTracking = function(audioElement) {
                if (!audioElement || currentAudio !== audioElement) {
                    // If not tracking this audio, update to track it
                    // But don't change song name if already set
                    if (audioElement) {
                        currentAudio = audioElement;
                        updatePlayPauseButton();
                        if (!progressUpdateInterval) {
                            startProgressUpdate();
                        }
                    }
                } else {
                    // Already tracking, just ensure progress updates are running
                    if (!progressUpdateInterval) {
                        startProgressUpdate();
                    }
                    updatePlayPauseButton();
                }
            };
            
            // Legacy function for backward compatibility
            window.showMusicPlayer = function(audioElement, songName) {
                showMusicPlayer(audioElement, songName);
            };
            
            window.hideMusicPlayer = function() {
                hideMusicPlayer();
            };
            
            window.updateMusicPlayerProgress = function() {
                updateProgress();
            };
            
            // Listen to audio events for state updates (secondary to marker detection)
            var audio1 = document.getElementById('audio1');
            var audio2 = document.getElementById('audio2');
            
            [audio1, audio2].forEach(function(audio, index) {
                if (!audio) return;
                
                // When audio starts playing, ensure player is tracking it
                audio.addEventListener('play', function() {
                    console.log('Audio play event:', {
                        audioId: 'audio' + (index + 1),
                        currentAudio: currentAudio,
                        audio: audio,
                        isInitialState: isInitialState
                    });
                    
                    // Don't update player during initial state (audio unlock)
                    // Only update when a marker has been detected
                    if (isInitialState) {
                        console.log('Ignoring audio play event during initial state');
                        return;
                    }
                    
                    // Always update music player when audio plays
                    // This ensures it's updated even if marker detection missed it
                    var songName = songNames['audio' + (index + 1)] || 'Audio Track ' + (index + 1);
                    
                    if (currentAudio !== audio) {
                        // If player isn't tracking this audio, update it
                        console.log('Updating music player for new audio:', songName);
                        showMusicPlayer(audio, songName);
                    } else {
                        // Already tracking, but ensure it's visible and updated
                        console.log('Audio already tracked, ensuring player is active');
                        initDOMElements();
                        if (musicPlayer) {
                            musicPlayer.classList.add('active');
                        }
                        if (songNameEl) {
                            // Trigger animation if song name is different
                            var previousName = songNameEl.textContent;
                            if (previousName !== songName) {
                                songNameEl.classList.add('updating');
                                setTimeout(function() {
                                    if (songNameEl) {
                                        songNameEl.classList.remove('updating');
                                    }
                                }, 400);
                            }
                            songNameEl.textContent = songName;
                        }
                        isPaused = false;
                        updatePlayPauseButton();
                    }
                    
                    // Ensure progress updates are running
                    if (!progressUpdateInterval) {
                        startProgressUpdate();
                    }
                });
                
                // Update button state when paused
                audio.addEventListener('pause', function() {
                    if (currentAudio === audio && audio.currentTime > 0) {
                        isPaused = true;
                        updatePlayPauseButton();
                    }
                });
                
                // Keep player visible when audio ends
                audio.addEventListener('ended', function() {
                    if (currentAudio === audio) {
                        isPaused = true;
                        updatePlayPauseButton();
                        // Keep progress update running to show final position
                        if (!progressUpdateInterval) {
                            startProgressUpdate();
                        }
                    }
                });
                
                // Update progress bar as audio plays
                audio.addEventListener('timeupdate', function() {
                    if (currentAudio === audio) {
                        updateProgress();
                    }
                });
            });
        })();
        </script>
    </body>
</html>

